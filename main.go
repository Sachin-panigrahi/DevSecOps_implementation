package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strings"
)

// Detailed responses for DevOps tools and concepts
var responses = map[string]string{
    "welcome": "I am Lily, your DevOps assistant. How can I help you today?",

    "ansible": "Ansible is an open-source automation tool used for configuration management, application deployment, and task automation. It uses YAML for defining configurations in a human-readable format and operates in an agentless manner over SSH or WinRM.",

    "terraform": "Terraform is an open-source infrastructure as code (IaC) tool by HashiCorp. It enables users to define and provision data center infrastructure using a declarative configuration language known as HashiCorp Configuration Language (HCL). Terraform manages resources across multiple cloud providers and services.",

    "git": "Git is a distributed version control system designed to handle projects of any size with speed and efficiency. It tracks changes in source code during development and facilitates collaboration among developers by managing different versions of code.",

    "github": "GitHub is a web-based platform for hosting Git repositories and providing tools for version control, collaboration, and project management. It supports features like pull requests, issues, actions, and project boards, enhancing team collaboration and code quality.",

    "docker": "Docker is a platform for developing, shipping, and running applications in containers. Containers bundle an application and its dependencies into a single, lightweight package that can run consistently across various environments, improving deployment reliability and efficiency.",

    "kubernetes": "Kubernetes is an open-source platform for container orchestration, automating the deployment, scaling, and management of containerized applications. It provides tools for managing containers in a clustered environment, including automated load balancing, scaling, and rolling updates.",

    "jenkins": "Jenkins is an open-source automation server used for continuous integration (CI) and continuous delivery (CD). It automates building, testing, and deploying code, integrating with a wide range of plugins to support various tools and services in the DevOps pipeline.",

    "github actions": "GitHub Actions is a CI/CD service integrated directly into GitHub. It allows you to create workflows to automate building, testing, and deploying code. Workflows are defined in YAML files and can trigger on various GitHub events such as pushes, pull requests, and releases.",

    "devops": "DevOps is a set of practices and cultural philosophies that aim to improve collaboration between development and IT operations teams. It focuses on automating and integrating the processes of software development and IT operations to accelerate delivery and improve software quality.",

    "continuous integration": "Continuous Integration (CI) is a practice where developers frequently integrate their code changes into a shared repository. Each integration is automatically verified by running builds and tests to detect issues early and improve code quality.",

    "continuous delivery": "Continuous Delivery (CD) extends CI by automating the deployment of code changes to production environments. It ensures that code is always in a deployable state, allowing for frequent and reliable releases with minimal manual intervention.",

    "infrastructure as code": "Infrastructure as Code (IaC) is a practice where infrastructure provisioning and management are performed using machine-readable configuration files. IaC allows for consistent and repeatable infrastructure deployments and is typically managed using tools like Terraform, Ansible, or CloudFormation.",

    "container orchestration": "Container orchestration refers to the automated management of containerized applications. Tools like Kubernetes and Docker Swarm are used to handle tasks such as deployment, scaling, and load balancing, ensuring the efficient operation of containerized applications in a cluster.",

    "ci/cd pipeline": "A CI/CD pipeline is a set of automated processes that allow for continuous integration and continuous delivery. It includes stages like code commit, build, test, and deploy, automating the movement of code from development to production while ensuring high quality and fast delivery.",

    "monitoring": "Monitoring involves continuously observing and analyzing the performance, availability, and health of systems and applications. Tools like Prometheus, Grafana, and ELK Stack (Elasticsearch, Logstash, Kibana) are commonly used for monitoring and logging purposes in DevOps environments.",

    "logging": "Logging refers to the collection and analysis of logs generated by applications and systems. It helps in diagnosing issues, understanding system behavior, and auditing. Logging tools like ELK Stack, Splunk, and Fluentd are used to aggregate and analyze logs from various sources.",

    "version control system": "A version control system (VCS) manages changes to source code over time. It allows multiple developers to collaborate on code, track changes, and revert to previous versions if needed. Git is a popular distributed VCS, while others include Subversion (SVN) and Mercurial.",

    "configuration management": "Configuration management involves maintaining and managing system configurations and settings across multiple servers. Tools like Ansible, Puppet, and Chef are used to automate configuration tasks, ensuring consistency and reducing manual intervention.",

    "deployment strategies": "Deployment strategies are methods used to release new versions of applications to production environments. Common strategies include Blue-Green Deployment, Canary Deployment, Rolling Updates, and Feature Toggles, each with its own benefits and use cases.",
    "thank you": "Least which I could do, See you again, Take Care !!! ",
}

// Function to get the response for a given message
func getResponse(message string) string {
    message = strings.ToLower(message)

    // Check for welcome message
    if strings.Contains(message, "hello") || strings.Contains(message, "hi") {
        return responses["welcome"]
    }

    // Check for specific keywords
    for keyword, response := range responses {
        if strings.Contains(message, keyword) {
            return response
        }
    }

    // Default response for unknown queries
    return "I'm sorry, I don't have information about that. Can I assist you with something else?"
}

// Handler for chat requests
func handleChat(w http.ResponseWriter, r *http.Request) {
    r.ParseForm()
    message := r.FormValue("message")
    response := getResponse(message)

    result := map[string]string{
        "response": response,
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(result)
}

// Handler for serving static files
func handleStaticFiles(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path == "/" || r.URL.Path == "/index.html" {
        http.ServeFile(w, r, "static/index.html")
        return
    }
    http.NotFound(w, r)
}

func main() {
    http.HandleFunc("/chat", handleChat)
    http.HandleFunc("/", handleStaticFiles)

    fmt.Println("Server listening on port 8081")
    if err := http.ListenAndServe(":8081", nil); err != nil {
        fmt.Println("Error starting server:", err)
    }
}

